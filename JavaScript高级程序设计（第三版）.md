
# JavaScript高级程序设计（第三版）笔记

 
> ## 前言：一个月大概读了个七七八八，对于本书知识点有了大体的印象，然而一些更深入的知识却没有完全掌握，故重读此书并加以记录，希望能在重读总结过程中能对知识巩固并加以提升。

### 第一章 JavaScript简介

- 诞生于1995年，当时主要功能：**客户端验证**


- 实现需要三部分
  + **ECMAScript**
  
      宿主环境有：web浏览器 ,Node和Adobe Flash
  + **DOM**
        
      将整个页面映射为一个多层节点结构
  + **BOM**
         
      无BOM标准可以遵循

### 第二章 在HTML中使用JavaScript

- 使用`<script>`元素来插入脚本（可直接将脚本代码写入或链接外域脚本）
   
  + `<script>`元素属性
  
         1.async   异步加载脚本及页面内容（但不保证同时拥有此属性的两个脚本的执行顺序）**只对外部文件有效**
  
         2.charset 表示通过src属性指定的代码的字符集，多数浏览器忽略其值

         3.defer  到文档完全被解析后（遇到</html\>后）脚本再运行（**立即下载，延迟运行**）**只对外部文件有效**

         4.language 已废弃

         5.src   表示外部文件地址（带有src属性的标签会忽略内部嵌入的代码）

         6.type  MIME类型  默认为“text/javascript”
                   
  + `<script>`元素的位置

         传统做法：放在`<head>`标签中  弊端：浏览器遇到<body/>元素才开始呈现页面内容，故所有脚本文件下载解析执行完成后才开始呈现

         建议做法：放在`</body>`前或包裹于`window.onload=function(){}`中

 + 使用外部文件的好处
 
         可维护性；可缓存（有多个页面共用一个js文件的时候可以加快页面加载速度）；适应未来（兼容XHTML和HTML）                       
                         
- 文档模式（主要影响CSS的执行）

   + 混杂模式（quirks mode）
   
         文档开始处没有文档类型声明或者声明错误，则会触发混杂模式

   + 标准模式（standards mode）
   + 准标准模式（almost standards mode）
   
          通过使用过渡型（transitional）或框架集型（frameset）文档类型来触发

- `<noscript>`元素

         <!--适用于浏览器不支持脚本 或 脚本被禁用 两种情况，正常情况不会显示内容-->
         
	       <noscript>
	     
	      <p>本页面需要浏览器支持（启用）JavaScript</p>
	    
	       </noscript>

### 第三章 基本概念

#### 语法
***
- 区分大小写
- 标识符
 + 第一个字符： 字母或下划线或美元符号$
 + 其他字符还可以是数字
 + 惯例：采用驼峰大小写格式
- 注释

         //单行注释

         /*
          *     多行注释
          *
          */
- 严格模式（strict mode）

         “use strict”; //在顶部添加将JS引擎切换到严格模式

          //或
        
          function doSomething()

          {       "use strict";//仅在此函数下使用严格模式
             
                  //函数体
          }

#### 关键字和保留字  
***
 + 均不能用作标识符
 + 在严格模式和非严格模式下保留字有所增减
####变量
***
 -  松散类型（可以用来保存任何类型的数据）
 -  局部变量和全局变量
    
              function test(){
                        var message="哈哈"；//定义局部变量
                     }
              test(); //执行一次函数
              alert(message);//错误 ，若在函数中定义变量时省略var，则定义了全局变量，此处将不会报错

 - 同时定义多个变量，用逗号分隔

               var me="Chinese" ，
                     him=“Japanese”，
                     you="Korean"；     

#### 数据类型
***
- Undefined 
      
	       var message;
	    
	       alert(message);//"undefined"
	     
	       alert(name);//抛出错误

		   alert（typeof message）；//“undefined”
		
		   alert（typeof name）；“undefined”

             //最好的做法是：每当定义一个变量的时候都应当赋予其初始值，这样当typeof操作符显示“undifined”时，我们就知道这个变量未声明
   
- Null

    		var message=null;

           alert(typeof message);//"object"      null值表示一个空对象指针

           alert（null == undefined;//"true"     undefined派生自null值

           //另外只要意在保存对象的变量还未真正保存对象，则应赋予其null值：一可体现null作为空对象指针的惯例；二可区分null和undefined

- Boolean


 	    /*字面值有true和false两个（注意区分大小写）

         *转型函数Boolean()可以将一个值转换为对应的布尔值
         *转换成false的有：空字符串，0和NaN，null，undefined

         * /
         
         //流控制语句会自动执行转换，如下：

         var name="zhang san";

         if(name){
 			alert("yes");  //  "yes"
             }
        
- Number

 + 浮点数值
    
        保存浮点数值需要的内存空间是保存整数值的两倍，故在ECMAScript中会尽量将浮点数转换为整数值
        
         尽量不要用浮点数值进行比较
  
 + 数值范围
   
         可以使用`isFinite（）`来判断是否无穷，不是则返回true      
 + NaN  

         任何涉及NaN的操作都会返回NaN；

         NaN与任何值都不相等，包括自身。

         可以调用`isNaN（）`函数来确定该数值是不是NaN

        `isNaN（）`也适用于对象，首先调用对象的`valueOf（）`方法，然后确定返回值能否转换为数值，若不能，基于返回值调用`toString（）`方法，再测试返回值

 + 数值转换

         `Number（）`

         可以用于任何数据类型（null值返回0，undefined值返回NaN，对象的话先调用`valueOf（）`，若返回NaN，则调用`toString()`）

         `parseInt()`
   
         专用于将字符串转换为数值

         从第一个开始解析，若为数字则继续，直到遇见非数值，然后输出

         空字符串则返回NaN

        可识别十六进制八进制，故可以为该函数提供第二个参数，指定按照哪一种进制进行解析

         `parseFloat（）`

          可解析第一个小数点，之后的小数点无效；

         始终忽略前导的0（只解析十进制值）；

         若字符串包含的是一个可以解析为整数的数（无小数点或小数点后全为0），则输出整数
        
- String

       + 双引号和单引号都ok
       +  ECMAScript中字符串一旦创建则值不能改变，故要赋予一个变量新的字符串值，则需要将原来的销毁，再用新的填充
       +  `toString（）`
           
        除了null和undefined值之外都有`toString（）`方法

        调用数值的时候可以传入转换进制数的参数，如下：(不传参默认十进制)

              var num=10；

              alert（num.toString(8)）;//  "12"

         还有`String()`方法，相当于对`toString（）`方法的扩展，在null和undefined值时返回“null”和“undefined”

- Object

     + Object类型是所有它的实例的基础---其所具有的任何属性和方法也存在于实例中
        
#### 操作符
***
- 一元操作符

  + 递增和递减操作符（++ 和 --）

         有前置型和后置型两种

         前置时先进行加减再求值，后置则是先求值再加减

  + 一元加和减操作符（+ 和 -）

         对非数值操作时会先用Number（）进行转换

- 位操作符

       用于在最底层按内存中表示数值的位来操作数值

       ECMAScript中所有数值都以IEEE-754  64位格式存储，由于位操作符不能操作64位值，故先将其转换为32位，然后执行操作，最后将结果转换为64位。

       有符号整数中，32位中的前31位用于表示整数的值，第32位表示数值符号（0 正 1 负）

       正数以纯二进制存储；

       负数使用二进制补码存储：1.求该数值绝对值的二进制码；2.反码并加1

            var num= - 8;

            alert(num.toString(2));   //  "-1000"     更合乎逻辑的形式

       对NaN和Infinity值应用位操作符时，都会被当成0处理

      + 按位非  ～

         结果就是返回数值的反码，实质是操作数负值再减一

      +  按位与  &
                  
         将二进制码对齐，对应位均为1时返回1，其余均为0      

      + 按位或  |
      
         只要对齐位有1则返回1，只有均为0时才返回0  

      + 按位异或  ^
      
         对齐位上只有一个1时返回1，其余情况均返回0       

      + 左移 <<
      
         会将数值的所有位向左移动（符号位不受影响），空出来的位用0补      

      + 有符号右移 >>
      
         将数值向右移动（符号位不受影响），空出来的位用0补

      + 无符号右移 >>>
      
         符号位受影响        

- 布尔操作符

  + 逻辑非  ！

        同时使用两个逻辑非，即！！，相当于模拟Boolean（）的行为

  +  逻辑与 &&

        不一定返回布尔值（具体见规则）

        属于短路操作，即第一个操作数能决定结果则不会对第二个操作数求值

  + 逻辑或 ||

        不一定返回布尔值

        属于短路操作

              var myObject=preferredObject || backupObject ;
           
              //如果pO中值不是null,那么它将被赋给mO；反之则将bO赋给mO

- 乘性操作符

     + 乘法    *
     + 除法  /
     + 求模  %  
     
  
- 加性操作符   

    加法操作符也可以用来连接字符串

- 关系操作符

     比较字符串时，会转化为字符编码进行比较

- 相等操作符

      ==  先转换再比较

      ===  只比较不转换

- 条件操作符

     即三目运算符

        var max=(num1>num2)？num1：num2 ；
 
        //若num1大于num2，则将num1赋给num，反之将num2赋给num 
   
- 赋值操作符

        num+=1；//类似于num=num+1；

- 逗号操作符

        var num=（5，4，3，2，1）；//num的值为1

      用于声明多个变量，以及赋值（如上）

#### 语句
***
